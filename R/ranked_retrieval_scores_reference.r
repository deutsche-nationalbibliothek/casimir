#' Helper Function for document-wise computation of ranked retrieval scores
#' dcg, ndcg and lrap
#'
#' Implemented as in Annif
#' https://github.com/NatLibFi/Annif/blob/master/annif/eval.py

#' Reference implementation of dcg to test against
#'
#' @param df a \code{data.frame} as generated by create_comparison
#' @param limit cut off value for dcgAtN
dcg_score <- function(df, limit = NULL) {
  # return the discounted cumulative gain (DCG) score for the selected
  #  labels vs. relevant labels

  df <- df |> dplyr::arrange(dplyr::desc(score))
  n_pred <- sum(!is.na(df$score))
  if (!is.null(limit)) n_pred <- min(limit, n_pred)

  gain <- df$gold[1:n_pred]
  discount <- log2(1:n_pred + 1)

  return(sum(gain / discount))
}

##########################################################################

#' Reference implementation for ndcg to test against
#'
#' @param gold_vs_pred a \code{data.frame} as generated by create_comparison
#' @param limit cut off value for ndcg at N
#'
#' @return numeric value of ndcg
ndcg_score <- function(gold_vs_pred, limit = NULL) {
  # return the normalized discounted cumulative gain (nDCG) score for the
  #  selected labels vs. relevant labels

  scores <- c()

  for (DOC_ID in unique(gold_vs_pred$doc_id)) {
    temp <- gold_vs_pred |> dplyr::filter(doc_id == DOC_ID)

    idcg <- dcg_score(
      temp |> dplyr::mutate(score = gold), limit
    )
    dcg <- dcg_score(
      temp, limit
    )

    if (idcg > 0) {
      scores <- c(scores, dcg / idcg)
    } else {
      scores <- c(scores, 1.0)
    }
  }

  return(mean(scores, na.rm = TRUE))
}

#' Reference implementation for Label Ranking Average Precision
#'
#' @param gold_vs_pred  a \code{data.frame} as generated by create_comparison
#'
#' @return numeric value of lrap
lrap_score <- function(gold_vs_pred) {
  # Compute ranking-based average precision.

  out <- c()

  for (DOC_ID in unique(gold_vs_pred$doc_id)) {
    temp <- gold_vs_pred |>
      dplyr::filter(doc_id == DOC_ID) |>
      dplyr::mutate(score = tidyr::replace_na(score, 0))

    relevant <- which(temp$gold)

    if (length(relevant) == 0) {
      aux <- 1.0
    } else {
      scores_i <- -temp$score
      rank <- rank(scores_i, ties.method = "max")[relevant]
      l <- rank(scores_i[relevant], ties.method = "max")

      # Manuelle Korrektur fÃ¼r False Negatives: l / rank = #TP / n_samples ~ 0
      aux <- mean((scores_i[relevant] < 0) * l / rank)
    }

    out <- c(out, aux)
  }

  mean(out, na.rm = TRUE)
}
